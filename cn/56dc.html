<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="referrer" content="same-origin"><meta name="referrer" content="no-referrer"><meta name="description" content="RDD的持久化机制"><meta name="keywords" content="大数据,BigData,数据开发,BI,数据分析,Hadoop,Spark,Flink,Hive,HBase"><link rel="alternate" href="/cn/atom.xml" title="马攀的技术栈"><link rel="shortcut icon" type="image/x-icon" href="/cn/favicon.ico?v=2.11.0"><link rel="canonical" href="https://mapan.tech/cn/56dc.html"><link rel="stylesheet" type="text/css" href="/cn/css/style.css?v=2.11.0"><script id="baidu_analytics">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?8a2255104fa5226d5e9ee3e7519e7ade";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script id="baidu_push">!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script>window.config={toc:!0,fancybox:!1,pjax:!1,latex:!1}</script><title>RDD的持久化机制 - 马攀的技术栈</title></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"><a href="/cn/." class="logo">马攀的技术栈</a></div><div class="mobile-navbar-icon"><span></span> <span></span> <span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/cn/"><li class="mobile-menu-item">首页</li></a><a href="/cn/categories.html"><li class="mobile-menu-item">分类</li></a><a href="/cn/about.html"><li class="mobile-menu-item">关于</li></a><a href="/cn/message.html"><li class="mobile-menu-item">留言</li></a><a href="/cn/links.html"><li class="mobile-menu-item">友链</li></a></ul></nav><div class="container" id="mobile-panel"><header id="header" class="header"><div class="logo-wrapper"><a href="https://mapan.tech" class="logo">马攀的技术栈</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"><a class="menu-item-link" href="/cn/">首页</a></li><li class="menu-item"><a class="menu-item-link" href="/cn/categories.html">分类</a></li><li class="menu-item"><a class="menu-item-link" href="/cn/about.html">关于</a></li><li class="menu-item"><a class="menu-item-link" href="/cn/message.html">留言</a></li><li class="menu-item"><a class="menu-item-link" href="/cn/links.html">友链</a></li></ul></nav></header><main id="main" class="main"><div class="content-wrapper"><div id="content" class="content"><article class="post"><header class="post-header"><h1 class="post-title">RDD的持久化机制</h1><div class="post-meta"><span class="post-time">2017-06-19 </span><span class="post-category"><a href="/cn/categories/Spark/">Spark</a> </span><span id="/cn/56dc.html" class="leancloud-visitors" data-flag-title="RDD的持久化机制">阅读数 <span class="leancloud-visitors-count">1000</span> </span><span class="post-count">字数统计 2k </span><span class="post-count">阅读时长 7</span></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">文章目录</h2><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDD的持久化机制"><span class="toc-text">RDD的持久化机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDD的缓存过程"><span class="toc-text">RDD的缓存过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#淘汰与落盘"><span class="toc-text">淘汰与落盘</span></a></li></ol></div></div><div class="post-content"><h3 id="RDD的持久化机制"><a href="#RDD的持久化机制" class="headerlink" title="RDD的持久化机制"></a>RDD的持久化机制</h3><p>弹性分布式数据集（RDD）作为 Spark 最根本的数据抽象，是只读的分区记录（Partition）的集合，只能基于在稳定物理存储中的数据集上创建，或者在其他已有的 RDD 上执行转换（Transformation）操作产生一个新的 RDD。转换后的 RDD 与原始的 RDD 之间产生的依赖关系，构成了血统（Lineage）。<strong>凭借血统，Spark</strong> <strong>保证了每一个</strong> <strong>RDD</strong> <strong>都可以被重新恢复</strong>。但 RDD 的所有转换都是惰性的，即只有当一个返回结果给 Driver 的行动（Action）发生时，Spark 才会创建任务读取 RDD，然后真正触发转换的执行。</p><p>Task 在启动之初读取一个分区时，会先判断这个分区是否已经被持久化，如果没有则需要检查 Checkpoint 或按照血统重新计算。所以如果一个 RDD 上要执行多次行动，可以在第一次行动中使用 persist 或 cache 方法，在内存或磁盘中持久化或缓存这个 RDD，从而在后面的行动时提升计算速度。</p><p>事实上，cache 方法是使用默认的 MEMORY_ONLY 的存储级别将 RDD 持久化到内存，故缓存是一种特殊的持久化。 <strong>堆内和堆外存储内存的设计，便可以对缓存</strong> <strong>RDD</strong> <strong>时使用的内存做统一的规划和管理</strong>。</p><p>RDD 的持久化由 Spark 的 Storage 模块负责，实现了 RDD 与物理存储的解耦合。Storage 模块负责管理 Spark 在计算过程中产生的数据，将那些在内存或磁盘、在本地或远程存取数据的功能封装了起来。在具体实现时 Driver 端和 Executor 端的 Storage 模块构成了主从式的架构，即 Driver 端的 BlockManager 为 Master，Executor 端的 BlockManager 为 Slave。</p><p>Storage 模块在逻辑上以 Block 为基本存储单位，<strong>RDD</strong> <strong>的每个</strong> <strong>Partition</strong> <strong>经过处理后唯一对应一个</strong> <strong>Block</strong>（BlockId 的格式为 rdd_RDD-ID_PARTITION-ID ）。Driver端的Master 负责整个 Spark 应用程序的 Block 的元数据信息的管理和维护，而Executor端的 Slave 需要将 Block 的更新等状态上报到 Master，同时接收 Master 的命令，例如新增或删除一个 RDD。</p><p><img src="/cn/56dc/clip_image001.jpg" alt="img"></p><p>在对 RDD 持久化时，Spark 规定了 MEMORY_ONLY、MEMORY_AND_DISK 等 7 种不同的<a href="http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence">存储级别 </a>，而存储级别是以下 5 个变量的组合：</p><p>resourceOffer代码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StorageLevel</span> <span class="title">private</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">private var _useDisk: <span class="type">Boolean</span>, //磁盘</span></span></span><br><span class="line"><span class="class"><span class="params">private var _useMemory: <span class="type">Boolean</span>, //这里其实是指堆内内存</span></span></span><br><span class="line"><span class="class"><span class="params">private var _useOffHeap: <span class="type">Boolean</span>, //堆外内存</span></span></span><br><span class="line"><span class="class"><span class="params">private var _deserialized: <span class="type">Boolean</span>, //是否为非序列化</span></span></span><br><span class="line"><span class="class"><span class="params">private var _replication: <span class="type">Int</span> = 1 //副本个数</span></span></span><br><span class="line"><span class="class"><span class="params"></span>)</span></span><br></pre></td></tr></table></figure><p>Spark中7种存储级别如下：</p><div class="table-container"><table><thead><tr><th><strong>持久化级别</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong>MEMORY_ONLY</strong></td><td>以非序列化的Java对象的方式持久化在JVM内存中。如果内存无法完全存储RDD所有的partition，那么那些没有持久化的partition就会在下一次需要使用它们的时候，重新被计算</td></tr><tr><td><strong>MEMORY_AND_DISK</strong></td><td>同上，但是当某些partition无法存储在内存中时，会持久化到磁盘中。下次需要使用这些partition时，需要从磁盘上读取</td></tr><tr><td><strong>MEMORY_ONLY_SER</strong></td><td>同MEMORY_ONLY，但是会使用Java序列化方式，将Java对象序列化后进行持久化。可以减少内存开销，但是需要进行反序列化，因此会加大CPU开销</td></tr><tr><td><strong>MEMORY_AND_DISK_SER</strong></td><td>同MEMORY_AND_DISK，但是使用序列化方式持久化Java对象</td></tr><tr><td><strong>DISK_ONLY</strong></td><td>使用非序列化Java对象的方式持久化，完全存储到磁盘上</td></tr><tr><td><strong>MEMORY_ONLY_2</strong> <strong>MEMORY_AND_DISK_2</strong> <strong>等等</strong></td><td>如果是尾部加了2的持久化级别，表示将持久化数据复用一份，保存到其他节点，从而在数据丢失时，不需要再次计算，只需要使用备份数据即可</td></tr></tbody></table></div><p>通过对数据结构的分析，可以看出存储级别从三个维度定义了 RDD 的 Partition（同时也就是 Block）的存储方式：</p><ol><li><strong>存储位置</strong>：磁盘／堆内内存／堆外内存。如 MEMORY_AND_DISK 是同时在磁盘和堆内内存上存储，实现了冗余备份。OFF_HEAP 则是只在堆外内存存储，目前选择堆外内存时不能同时存储到其他位置。</li><li><strong>存储形式</strong>：Block 缓存到存储内存后，是否为非序列化的形式。如 MEMORY_ONLY 是非序列化方式存储，OFF_HEAP 是序列化方式存储。</li><li><strong>副本数量</strong>：大于 1 时需要远程冗余备份到其他节点。如 DISK_ONLY_2 需要远程备份 1 个副本。</li></ol><h3 id="RDD的缓存过程"><a href="#RDD的缓存过程" class="headerlink" title="RDD的缓存过程"></a>RDD的缓存过程</h3><p>RDD 在缓存到存储内存之前，Partition 中的数据一般以迭代器（<a href="http://www.scala-lang.org/docu/files/collections-api/collections_43.html">Iterator</a>）的数据结构来访问，这是 Scala 语言中一种遍历数据集合的方法。通过 Iterator 可以获取分区中每一条序列化或者非序列化的数据项(Record)，这些 Record 的对象实例在逻辑上占用了 JVM 堆内内存的 other 部分的空间，<strong>同一</strong> <strong>Partition</strong> <strong>的不同</strong> <strong>Record</strong> <strong>的存储空间并不连续</strong>。</p><p>RDD 在缓存到存储内存之后，Partition 被转换成 Block，Record 在堆内或堆外存储内存中占用一块连续的空间。<strong>将Partition由不连续的存储空间转换为连续存储空间的过程，Spark称之为”展开”（Unroll）</strong>。</p><p>Block 有序列化和非序列化两种存储格式，具体以哪种方式取决于该 RDD 的存储级别。非序列化的 Block 以一种 DeserializedMemoryEntry 的数据结构定义，用一个数组存储所有的对象实例，序列化的 Block 则以 SerializedMemoryEntry的数据结构定义，用字节缓冲区（ByteBuffer）来存储二进制数据。每个 Executor 的 Storage 模块用一个链式 Map 结构（LinkedHashMap）来管理堆内和堆外存储内存中所有的 Block 对象的实例，对这个 LinkedHashMap 新增和删除间接记录了内存的申请和释放。</p><p><strong>因为不能保证存储空间可以一次容纳</strong> <strong>Iterator</strong> <strong>中的所有数据，当前的计算任务在</strong> <strong>Unroll</strong> <strong>时要向</strong> <strong>MemoryManager</strong> <strong>申请足够的</strong> <strong>Unroll</strong> <strong>空间来临时占位，空间不足则</strong> <strong>Unroll</strong> <strong>失败，空间足够时可以继续进行</strong>。</p><p>对于序列化的 Partition，其所需的 Unroll 空间可以直接累加计算，一次申请。</p><p>对于非序列化的 Partition 则要在遍历 Record 的过程中依次申请，即每读取一条 Record，采样估算其所需的 Unroll 空间并进行申请，空间不足时可以中断，释放已占用的 Unroll 空间。</p><p>如果最终 Unroll 成功，当前 Partition 所占用的 Unroll 空间被转换为正常的缓存 RDD 的存储空间，如下图所示。</p><p><img src="/cn/56dc/clip_image002.jpg" alt="img"></p><p>Spark Unroll</p><p>在静态内存管理时，Spark 在存储内存中专门划分了一块 Unroll 空间，其大小是固定的，统一内存管理时则没有对 Unroll 空间进行特别区分，当存储空间不足时会根据动态占用机制进行处理。</p><h3 id="淘汰与落盘"><a href="#淘汰与落盘" class="headerlink" title="淘汰与落盘"></a>淘汰与落盘</h3><p><strong>由于同一个</strong> <strong>Executor</strong> <strong>的所有的计算任务共享有限的存储内存空间，当有新的</strong> <strong>Block</strong> <strong>需要缓存但是剩余空间不足且无法动态占用时，就要对</strong> <strong>LinkedHashMap</strong> <strong>中的旧</strong> <strong>Block</strong> <strong>进行淘汰（Eviction），而被淘汰的</strong> <strong>Block</strong> <strong>如果其存储级别中同时包含存储到磁盘的要求，则要对其进行落盘（Drop），否则直接删除该</strong> <strong>Block</strong>。</p><p>存储内存的淘汰规则为：</p><ul><li>被淘汰的旧 Block 要与新 Block 的 MemoryMode 相同，即同属于堆外或堆内内存；</li><li>新旧 Block 不能属于同一个 RDD，避免循环淘汰；</li><li>旧 Block 所属 RDD 不能处于被读状态，避免引发一致性问题；</li><li>遍历 LinkedHashMap 中 Block，按照最近最少使用（LRU）的顺序淘汰，直到满足新 Block 所需的空间。其中 LRU 是 LinkedHashMap 的特性。</li></ul><p>落盘的流程则比较简单，如果其存储级别符合_useDisk 为 true 的条件，再根据其_deserialized 判断是否是非序列化的形式，若是则对其进行序列化，最后将数据存储到磁盘，在 Storage 模块中更新其信息。</p></div><div class="post-copyright"><p class="copyright-item"><span>原文作者: </span><a href="https://mapan.tech/cn">MaPan</a></p><p class="copyright-item"><span>原文链接: </span><a href="https://mapan.tech/cn/56dc.html">https://mapan.tech/cn/56dc.html</a></p><p class="copyright-item"><span>许可协议: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a></p></div><footer class="post-footer"><nav class="post-nav"><a class="prev" href="/cn/51f3.html"><i class="iconfont icon-left"></i> <span class="prev-text nav-default">Hadoop序列化</span> <span class="prev-text nav-mobile">上一篇</span> </a><a class="next" href="/cn/5ef7.html"><span class="next-text nav-default">shell基本语法</span> <span class="prev-text nav-mobile">下一篇</span> <i class="iconfont icon-right"></i></a></nav></footer></article></div><div class="comments" id="comments"><div id="vcomments"></div></div></div></main><footer id="footer" class="footer"><div class="social-links"><a href="/cn/atom.xml" class="iconfont icon-rss" title="rss" target="_blank"></a></div><div class="copyright"><span class="division">&nbsp;</span><span class="post-count"> 全站字数 80.7k </span><span class="copyright-year">Since 2015 <span class="heart"><i class="iconfont icon-heart"></i> </span><span class="author">MaPan</span></span></div></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script src="./lib/valine/av-min.js?v=3.0.4"></script><script src="./lib/valine/Valine.min.js"></script><script type="text/javascript">new Valine({el:"#vcomments",notify:!1,verify:!0,app_id:"XtxvAXPwOzM9noIc3eyxi3AS-gzGzoHsz",app_key:"yEVQszyxb4bwLuAGU5VHnPR8",placeholder:"说点什么吧...",avatar:"mm",visitor:"ture"})</script><script type="text/javascript" src="/cn/lib/jquery/jquery.min.js"></script><script type="text/javascript" src="/cn/lib/slideout/slideout.js"></script><script type="text/javascript" src="/cn/js/src/even.js?v=2.11.0"></script></body></html>